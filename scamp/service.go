package scamp

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"encoding/base64"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"os" // "encoding/json"
	"sync"
	"sync/atomic"
	"time"
)

func init() {
	initSCAMPLogger()
	return
}

const (
	defaultMessageTimeout  = time.Second * 120
	defaultLivenessDirPath = "/backplane/running-services/"
	defaultConfigPath      = "/backplane/etc"
	defaultPrivatePath     = "/etc/GT_private/services"
)

// DefaultCache is the default service cache
// TODO: this probably shouldn't be a global variable (or exported)
var DefaultCache *ServiceCache

// ServiceActionFunc represents a service callback
type ServiceActionFunc func(*Message, *Client)

// ServiceAction interface
type ServiceAction struct {
	handler  ServiceActionFunc
	crudTags string
	version  int
}

// Options that can be passed at time of service creation
// TODO: after doing so, define defaultServiceOptions (in Init()) to set these values when
// a user doesn't
type Options struct {
	// KeyPath path to service private key
	KeyPath string
	// CertPath path to certificate used for signing
	CertPath string
	// AnnouncePath payload to be signed TODO: this field might not be needed
	AnnouncePath string
	// SOAConfigPath path to the soa.conf file
	// the soa.conf file must include the following keys:
	//	1) discovery.cache_path
	SOAConfigPath string
	// LivenessFilePath in Kubernetes environments, scamp services write an empty file to a
	// designated directory to facilitate auto-scaling
	LivenessFilePath string
	// the discovery multicast IP, if this is not set the service uses the discovery.multicast_address
	// key in the soa.conf file
	//MultiCastIP net.IP
}

var defaultServiceOptions = Options{
	KeyPath:          defaultPrivatePath,
	CertPath:         defaultPrivatePath,
	AnnouncePath:     "",
	SOAConfigPath:    defaultConfigPath,
	LivenessFilePath: defaultLivenessDirPath,
}

// Service represents a scamp service
type Service struct {
	options      Options
	desc         ServiceDesc
	listener     net.Listener
	listenerIP   net.IP
	listenerPort int

	actions        map[string]*ServiceAction
	isRunning      bool
	statsCloseChan chan bool

	mu                  sync.Mutex
	serveWG             sync.WaitGroup // counts active Serve goroutines for GracefulStop
	clients             []*Client
	cert                tls.Certificate
	pemCert             []byte // just a copy of what was read off disk at tls cert load time
	quit                chan struct{}
	done                chan struct{}
	connectionsAccepted uint64
}

// ServiceDesc contains service description fields
type ServiceDesc struct {
	// Sector represents the scamp sector that the service is announced with, i.e. "main",
	// "channel_module", "payment", etc...
	Sector string
	// ServiceSpec contains the service specification used for listening/announcing
	ServiceSpec string
	// HumanName is the human readable name of the service, i.e. "sdk_service",
	// "payment_service", etc...
	HumanName string
	// name is an autogenerated service name, this name is HumanName appended with am 18 byte random
	// string of base64 encoded characters
	name string
}

// merge takes the passed in opts struct and updates nil or empty fields with default values
func (o *Options) merge() {
	if o == nil {
		o = &defaultServiceOptions
	} else {
		if len(o.AnnouncePath) == 0 {
			o.AnnouncePath = defaultServiceOptions.AnnouncePath
		}
		if len(o.CertPath) == 0 {
			o.CertPath = defaultServiceOptions.CertPath
		}
		if len(o.KeyPath) == 0 {
			o.KeyPath = defaultServiceOptions.KeyPath
		}
		if len(o.LivenessFilePath) == 0 {
			o.LivenessFilePath = defaultServiceOptions.LivenessFilePath
		}
		if len(o.SOAConfigPath) == 0 {
			o.SOAConfigPath = defaultServiceOptions.SOAConfigPath
		}
	}
}

// NewService initializes and returns pointer to a new scamp service
func NewService(desc ServiceDesc, opts *Options) (*Service, error) {
	if opts == nil {
		opts = &Options{}
	}

	err := validateServiceDesc(desc)
	if err != nil {
		Error.Fatalf("couldn't create service: %s", err)
	}
	opts.merge()

	err = initConfig(opts.SOAConfigPath)
	if err != nil {
		log.Fatal("could not initialize scamp environment: ", err)
	}

	cachePath, ok := DefaultConfig().Get("discovery.cache_path")
	if !ok {
		log.Fatal("no such config param `discovery.cache_path`: this key must be present in soa.conf to use scamp-go")
	}

	cache, err := NewServiceCache(cachePath)
	if err != nil {
		Error.Fatalf("couldn't create service cache: %s", err)
	}
	DefaultCache = cache

	crtPath := DefaultConfig().ServiceCertPath(desc.HumanName, opts.CertPath)
	keyPath := DefaultConfig().ServiceKeyPath(desc.HumanName, opts.KeyPath)

	if crtPath == nil || keyPath == nil {
		err = fmt.Errorf(
			"could not find valid crt/key pair for service %s, using %s, %s",
			desc.HumanName,
			opts.CertPath,
			opts.KeyPath,
		)
		return nil, err
	}

	keypair, err := tls.LoadX509KeyPair(string(crtPath), string(keyPath))
	if err != nil {
		return nil, err
	}

	service := &Service{
		desc:    desc,
		actions: make(map[string]*ServiceAction),
		cert:    keypair,
		pemCert: loadPEMCertBytes(string(crtPath)),
	}
	service.generateRandomName()

	err = service.listen()
	if err != nil {
		return nil, err
	}

	service.statsCloseChan = make(chan bool)
	return service, nil
}

// TODO: port discovery and interface/IP discovery should happen here
// important to set values so announce packets are correct
func (s *Service) listen() (err error) {
	config := &tls.Config{
		Certificates: []tls.Certificate{s.cert},
	}

	Info.Printf("starting service on %s", s.desc.ServiceSpec)
	// TODO: I'm pretty sure that tls 1.2 requires specific ports (e.g. 443,465,993,995)
	// need to ensure that we are using those ports if we are using or going to use tls 1.2 for RPC
	s.listener, err = tls.Listen("tcp", s.desc.ServiceSpec, config)
	if err != nil {
		return fmt.Errorf("Failed to listen %v", err)
	}

	addr := s.listener.Addr()
	Info.Printf("service now listening to %s", addr.String())

	s.listenerIP, err = getIPForAnnouncePacket()
	if err != nil {
		return
	}

	s.listenerPort = s.listener.Addr().(*net.TCPAddr).Port
	return
}

// Register registers a service handler callback
func (s *Service) Register(name string, handler ServiceActionFunc) (err error) {
	if s.isRunning {
		err = errors.New("cannot register handlers while server is running")
		return
	}

	s.actions[name] = &ServiceAction{
		handler: handler,
		version: 1,
	}
	return
}

//Run starts a scamp service serving
func (s *Service) Run() error {
	err := s.createKubeLivenessFile(s.options.LivenessFilePath)
	if err != nil {
		fmt.Println(err)
	}

	// sleep on accept failure (for backoff)
	var delay time.Duration

	for {
		netConn, err := s.listener.Accept()
		if err != nil {
			if ne, ok := err.(interface {
				Temporary() bool
			}); ok && ne.Temporary() {
				if delay == 0 {
					delay = 5 * time.Millisecond
				} else {
					delay *= 2
				}
				if max := 1 * time.Second; delay > max {
					delay = max
				}
				timer := time.NewTimer(delay)
				select {
				case <-timer.C:
				case <-s.quit:
					timer.Stop()
					return nil
				}
				continue
			}
			select {
			case <-s.quit:
				return nil
			default:
			}
			return err
		}

		// NOTE: our listener was created with tls.Listen() so any connection we accept is
		// already "wrapped" with TLS but we have to assert the type here to store it
		delay = 0
		tlsConn := (netConn).(*tls.Conn)
		if tlsConn == nil {
			Error.Printf("could not create tls connection")
			break
		}

		// TODO: maybe we shouldn't bother creating "clients"
		// for incoming connections when we can just use the connection directly
		// it would be less overhead. Clients make sense for re-using connections
		// that we initiate but not for this case
		conn := NewConnection(tlsConn, "service")
		client := NewClient(conn)

		s.mu.Lock()
		s.clients = append(s.clients, client)
		s.mu.Unlock()
		s.serveWG.Add(1)
		go func() {
			s.Handle(client)
			s.serveWG.Done()
		}()
		//TODO: Do we need this?
		atomic.AddUint64(&s.connectionsAccepted, 1)
	}

	s.mu.Lock()
	for _, client := range s.clients {
		client.Close()
	}
	s.mu.Unlock()

	s.statsCloseChan <- true
	return nil
}

//Handle handles incoming client messages received via the cient MessageChan
func (s *Service) Handle(client *Client) {
	var action *ServiceAction
	//Info.Printf("handling client for remote connection: %s\n", client.conn.conn.RemoteAddr())

handlerLoop:
	for {
		select {
		case msg, ok := <-client.Incoming():
			if !ok {
				break handlerLoop
			}
			action = s.actions[msg.Action]

			if action != nil {
				// Info.Printf("handling action %s\n", action.crudTags)
				action.handler(msg, client)
			} else {
				Error.Printf("do not know how to handle action `%s`", msg.Action)

				reply := NewMessage()
				reply.SetMessageType(MessageTypeReply)
				reply.SetEnvelope(EnvelopeJSON)
				reply.SetRequestID(msg.RequestID)
				reply.Write([]byte(`{"error": "no such action"}`))
				_, err := client.Send(reply)
				if err != nil {
					client.Close()
					break handlerLoop
				}
			}
		case <-time.After(defaultMessageTimeout):
			break handlerLoop
		}
	}

	client.Close()
	s.RemoveClient(client)
}

// RemoveClient removes a client from the scamp service
func (s *Service) RemoveClient(client *Client) (err error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	index := -1
	for i, entry := range s.clients {
		if client == entry {
			index = i
			break
		}
	}

	if index == -1 {
		Error.Printf("tried removing client that wasn't being tracked")
		return fmt.Errorf("unknown client") // TODO get the client's IP?
	}

	client.Close()
	s.clients = append(s.clients[:index], s.clients[index+1:]...)

	return nil
}

// Stop closes the service's net.Listener
// TODO: refactor
func (s *Service) Stop() {
	s.mu.Lock()
	defer s.mu.Unlock()

	if s.listener != nil {
		s.listener.Close()
	}
	Warning.Println("shutting down")

	err := s.removeKubeLivenessFile(s.options.LivenessFilePath)
	if err != nil {
		fmt.Println("could not remove liveness file: ", err)
	}
	Info.Println("shutdown done")
}

// MarshalText serializes a scamp service for discovery broadcast
func (s *Service) MarshalText() (b []byte, err error) {
	var buf bytes.Buffer

	serviceProxy := serviceAsServiceProxy(s)

	classRecord, err := serviceProxy.MarshalJSON() //json.Marshal(&serviceProxy) //Marshal is mangling service actions
	if err != nil {
		return
	}
	sig, err := signSHA256(classRecord, s.cert.PrivateKey.(*rsa.PrivateKey))
	if err != nil {
		return
	}
	sigParts := stringToRows(sig, 76)

	buf.Write(classRecord)
	buf.WriteString("\n\n")
	buf.Write(s.pemCert)
	buf.WriteString("\n\n")
	for _, part := range sigParts {
		buf.WriteString(part)
		buf.WriteString("\n")
	}
	buf.WriteString("\n")

	b = buf.Bytes()
	return
}

func stringToRows(input string, rowlen int) (output []string) {
	output = make([]string, 0)

	if len(input) <= 76 {
		output = append(output, input)
	} else {
		substr := input[:]
		var row string
		done := false
		for {
			if len(substr) > 76 {
				row = substr[0:76]
				substr = substr[76:]
			} else {
				row = substr[:]
				done = true
			}
			output = append(output, row)
			if done {
				break
			}
		}
	}

	return
}

func (s *Service) generateRandomName() {
	randBytes := make([]byte, 18, 18)
	read, err := rand.Read(randBytes)
	if err != nil {
		// we can't announce a scamp service without a unique name so bail out
		Error.Fatalf("could not generate all rand bytes needed. only read %d of 18", read)
	}

	base64RandBytes := base64.StdEncoding.EncodeToString(randBytes)

	var buffer bytes.Buffer
	buffer.WriteString(s.desc.HumanName)
	buffer.WriteString("-")
	buffer.WriteString(base64RandBytes[0:])
	s.desc.name = string(buffer.Bytes())
}

// createKubeLivenessFile creates an empty file in the defaultLivenessDirPath to facilitate
// kubernetes auto-scaling
func (s *Service) createKubeLivenessFile(path string) error {
	if _, err := os.Stat(path); os.IsNotExist(err) {
		err = os.MkdirAll(path, 0755)
		if err != nil {
			return err
		}
	}

	file, err := os.Create(path + s.desc.HumanName)
	if err != nil {
		return err
	}
	defer file.Close()
	return nil
}

func (s *Service) removeKubeLivenessFile(path string) error {
	p := path + s.desc.HumanName
	err := os.Remove(p)
	if err != nil {
		return err
	}
	return nil
}

// validateServiceDesc checks that all ServiceDesc fields are provided
// and returns an error if any are blank
func validateServiceDesc(desc ServiceDesc) error {
	if len(desc.HumanName) > 18 {
		return fmt.Errorf("desc.HumanName must be less than 18 bytes")
	}
	if len(desc.HumanName) == 0 {
		return fmt.Errorf("desc.HumanName cannot be empty")
	}
	if len(desc.Sector) == 0 {
		return fmt.Errorf("desc.Sector cannot be empty")
	}
	if len(desc.ServiceSpec) == 0 {
		return fmt.Errorf("desc.ServiceSpec cannot be empty")
	}
	return nil
}

// loadPEMCertBytes loads certificate file as bytes
func loadPEMCertBytes(filePath string) []byte {
	pemCert, err := ioutil.ReadFile(filePath)
	if err != nil {
		log.Fatal("could not load certificate file")
	}
	return bytes.TrimSpace(pemCert)
}
